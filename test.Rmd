```{r}
functionDir <- "./R/"
functionList <- list.files(path = functionDir)
for(i in functionList){
  source(paste0(functionDir,i))
}
```

```{r}
#testthat, ggplot2, GGally, roxygen2, stats, ggrepel, dplyr??, ggpubr??
usethis::use_package("ggplot2")
usethis::use_package("plotly") # used for matspec
usethis::use_package("PRROC") # used for 


```
#load data to test functions
```{r}
ann<-local(get(load("~/OneDrive - Murdoch University/datasets/covid19/bioGune/dataElements/covid19_bioGune_PLA_ANN.daE")))
aaMeta1<-ann@obsDescr[[1]]

aa<-local(get(load(file.path("~/OneDrive - Murdoch University/datasets/covid19/bioGune/dataElements/covid19_bioGune_PLA_SPC.daE"))))
aaData<-data.frame(apply(aa@.Data,2,as.numeric)) #spc/glyc data
aaMeta2<-aa@obsDescr[[1]] #metadata from PLA_SPC.daE file

# match SpcGlyc numeric and both Annotations
aaMeta1<-aaMeta1[which(aaMeta1$sampleID %in% aaMeta2$sampleID),]
aaData<-aaData[which(aaMeta2$sampleID %in% aaMeta1$sampleID),]
aaMeta2<-aaMeta2[which(aaMeta2$sampleID %in% aaMeta1$sampleID),]

#make a final annotation file
aaMetaF<-merge(aaMeta1,
                  aaMeta2,
                  by.x ="sampleID",by.y = "sampleID")
rm(aaMeta1, aaMeta2, aa, ann)

#combine the numeric and meta data
BIOspcglyc<-cbind(aaData, aaMetaF)
rm(aaData, aaMetaF)

#Organise the data as you wish 

which(BIOspcglyc[, 1:8]=="Inf")
which(is.na(BIOspcglyc[, 1:8]))
which(is.na(BIOspcglyc$age))
unique(BIOspcglyc$sex)

unique(BIOspcglyc$group)
BIOspcglyc$covid_status<-ifelse(BIOspcglyc$group =="COVID-pos","covid", ifelse(BIOspcglyc$group=="preCOVID","control", "control"))

library(fusion)
library(dplyr)
lipo<-local(get(load("~/OneDrive - Murdoch University/datasets/covid19/cambridgeFollowUpPart2/DataElements/covid19_cambridge_ORI_FU1_FU2_PLA_LIPO.daE")))
LIPO<-data.frame(apply(lipo@.Data,2,as.numeric))
LIPO_ANN<-lipo@obsDescr[[1]]

ann<-local(get(load("~/OneDrive - Murdoch University/datasets/covid19/cambridge/DataElements/covid19_cambridge_PLA_ANN_fix.daE")))
#ann<-local(get(load("~/Downloads/covid19_cambridge_PLA_ANN.daE")))
ann = ann@obsDescr[[1]]

#matching the annotation file fo the LIPO_ANN file

ann<-ann[which(ann$sampleID %in% LIPO_ANN$sampleID),]
LIPO<- LIPO[which(LIPO_ANN$sampleID %in% ann$sampleID),]
LIPO_ANN<- LIPO_ANN[which(LIPO_ANN$sampleID %in% ann$sampleID),]

LIPO<- LIPO[match(ann$sampleID, LIPO_ANN$sampleID),]
LIPO_ANN<- LIPO_ANN[match(ann$sampleID, LIPO_ANN$sampleID),]

df<-cbind(LIPO, ann)
rm(ann, LIPO, LIPO_ANN)
```
#####remove samples with NA for age or group_facet_letter
```{r}
df2 <-
  df %>%
  filter(!is.na(age)) %>%
  filter(!is.na(group_facet_letter))%>%
  group_by(group_facet_letter, gender) 
```

#####check for inf values
```{r}
which(df2 == "Inf", arr.ind = TRUE)

#remove rows with Inf values for lipoprotein quantities
df3 <- df2[-c(49,70,548),]

rm(df, df2)
```
```

#tests pcagrid
```{r}
#usethis, usepackage, use vignette, list.re

loadPackages(myPackages = c("ggplot2",
                            "stats",
                            "roxygen2",
                            "testthat",
                            #"ggpmisc",
                            #"ggplotly",
                            #"plotly",
                            "tidyverse", 
                            #"ggpubr",
                            "GGally",
                            #"cowplot",
                            #"gridExtra",
                            #"rlist",
                            "ggrepel",
                            #"ellipse",
                            #"HotellingEllipse",
                            "sp"))
#1) create PCA object
a <- PCA(BIOspcglyc[,1:8], annotation = BIOspcglyc[,-1:-8])
a1 <- PCA(df3[,1:112], annotation = df3[,-1:-112], rank = 20)
# #2) create screeCumulativeThresholdObject
# b <- screeCumulativeThreshold(PCAObject = a, cutoff = 95)
# 
# #3) gridplot tests various combinations
# ##working
# a1<-pcaGrid(screeCumulativeThresholdObject = b, gridTitle = "Trial Grid title", CO="covid_status", COtitle = "Covid", SH="sex",hotelStat = TRUE)
# a1[["plots"]][["pcaGridPlot"]]
# a3 <-pcaGrid(screeCumulativeThresholdObject = b, CO = "covid_status", SZ = "age", AL = "bmi", COtitle = "Covid", SZtitle = "Age", ALtitle = "BMI")
# 
# a2 <- pcaGrid(screeCumulativeThresholdObject = b, CO = "covid_status", SZ = 5, COtitle = "covid", SZtitle = "Age")
# pcaGrid(screeCumulativeThresholdObject = b, CO = "covid_status", SH = "sex", SZ = "age", AL = 1, COtitle = "covid")
# 
# pcaGrid(screeCumulativeThresholdObject = b, CO = "covid_status", SH = NULL, SZ = "age", AL = 1, COtitle = "covid")
# pcaGrid(screeCumulativeThresholdObject = b, CO = "covid_status", SH = NULL, SZ = 5, AL = "age", COtitle = "covid")
# pcaGrid(screeCumulativeThresholdObject = b, CO = "covid_status", SH = "sex", SZ = "age", AL = 1, COtitle = "covid")
# pcaGrid(screeCumulativeThresholdObject = b, CO = "covid_status", SH = "sex", SZ = 5, AL = "age", COtitle = "covid")
# pcaGrid(screeCumulativeThresholdObject = b, CO = "covid_status", SH = "sex", SZ = "age", AL = "bmi", COtitle = "covid")
# p1 <-pcaGrid(screeCumulativeThresholdObject = b, CO = "covid_status", SH = NULL, SZ = "age", AL = "bmi", COtitle = "covid")
# pcaGrid(screeCumulativeThresholdObject = b, CO = "work_activity", SH = NULL, SZ = 5, AL = 1, COtitle = "covid")
# 
# 
# opt=list(colour= "covid_status")

#2) 
fff<- plotScores(model=a, optns=list(colour=BIOspcglyc[,"age"], shape=BIOspcglyc[,"sex"], ellipse="normal", outlierLabels=row.names(BIOspcglyc)))
fff[["plots"]][["pcaGrid"]]

#2)
fff<- plotLoadings(model= a)
fff[["plots"]][["plotLoadingGrid"]]
```
```{r}
data("iris")
a<-PCA(data=iris[,1:4], annotation = iris[,5])
b<-plotScores(model=a, optns=list(colour=iris[,5], colourTitle="species", ellipse="T", outlierLabels=rownames(iris), thresh=3))
b[["plots"]][["pcaGrid"]]

b[["plots"]][["pcaGrid"]][2,2]

c<-plotLoadings(model = a)
c[["plots"]][["plotLoadingGrid"]]

#access single plot via [j,i]
c[["plots"]][["plotLoadingGrid"]][1,1]
```

#foldchange
```{r}

a <- PCA(BIOspcglyc[,1:8], annotation = BIOspcglyc[,-1:-8])
factor = BIOspcglyc[,"covid_status"]
a$data$rawData$factor <- as.numeric(as.factor(factor))

  df <- a$data$rawData

  idx<- which(df[,"factor"] == 1)
  control <- df[idx,]
  treatment <- df[-idx,]

 #logmeans
 c <- log2(apply(X = control, MARGIN = 2, FUN = mean))
 t <- log2(apply(X = treatment, MARGIN = 2, FUN = mean))

 log2fc <- c-t
log2fc <- as.data.frame(log2fc)

foldChange(model = a, factor = BIOspcglyc[,"covid_status"])

```

```{r}
factor<-BIOspcglyc[,"covid_status"]

a$data$rawData$factor <- as.numeric(as.factor(factor))

id <- as.data.frame(colnames(a$data$rawData))
    df <- a$data$rawData
    
  if(any(id=="factor")){
    idx <- which(id == "factor")
    id <- as.data.frame(id[-idx,])
  }
    #else{print("NO")}
    
#correlations between scaled + centered original data and scores

  corr<-t(as.data.frame(cor(a$data$scores[,1], a$data$dataSC)))

# ##cliffs delta manually
    rescale.factor = (n*m-1)/(n*m)
    idx<- which(df[,"factor"]==1)
    control <- df[idx,]
    treatment <- df[-idx,]

    #control
    c<-list()
    for(i in 1:(ncol(control)-1)){
      c[[i]] <- sort(control[,i])
    }

    #treatment
    t<-list()
    for(i in 1:(ncol(treatment)-1)){
      t[[i]] <- sort(treatment[,i])
    }

    #dominance matrix
    d<-list()
    for(i in 1:(ncol(df)-1)){
      d[[i]] <-sign(outer(t[[i]], c[[i]], FUN="-"))
    }

    #cliffs delta
    cd<-list()
    for(i in 1:(ncol(df)-1)){
      cd[[i]]<-mean(d[[i]])
    }

    for(i in 1:(ncol(df)-1)){
      ifelse(test = abs(cd[[i]])==1, yes = cd[[i]]*rescale.factor, no=cd)
    }
unlist(cd)
cd<-t(as.data.frame(cd))

#adjusted p-value
pval<-list()
for(i in 1:(ncol(df)-1)){
  pval[[i]]<-kruskal.test(df[,i],df[,"factor"])$p.value
}

unlist(pval)
pvalAdjusted <- p.adjust(pval, method = "BH")
pvalRescaled <- abs(log10(pvalAdjusted))
pvalRescaled<-as.data.frame(pvalRescaled)

#loadings and id

pcLoadings<-as.data.frame(a$data$loadings[,1])

id<-as.data.frame(row.names(pcLoadings))

#eruption data frame
ed<-cbind(cd, pvalRescaled, pcLoadings, id, corr)

colnames(ed)<-c("cd", "pvalRescaled", "PC1loadings", "id", "correlation")

ggplot(data=ed, aes(x=cd, y=PC1loadings, color=pvalRescaled))+ 
  geom_label_repel(aes(label = id),
                   colour = "black") 

#plot
ggplot(data=ed, aes(x = cd,
                                    y = PC1loadings,
                                    colour = corr)) +
  geom_label_repel(aes(label = id),
                   colour = "black",
                   min.segment.length = 0.001) +
  geom_point(size = 3,
             shape = 1) +
  geom_point(size = 3,
             shape = 16,
             alpha = 0.3) +
  theme_bw() +
  scale_x_continuous(limits = c(-1, 1)) +
  scale_colour_gradientn(colours = rainbow(7)) +
  labs(x = "Cliff's Delta",
       y = "PC1 Loadings") +
  theme(panel.grid.minor = element_blank(),
        plot.tag = element_text(face = "bold",
                                size = 25),
        legend.position = "right",
        legend.direction = "vertical")

d<-eruptionPlot(model=a, factor=BIOspcglyc[,"covid_status"], optns=list(PC=2))
d[["plots"]][["eruptionPlot"]]


data(mtcars)
 
a <- PCA(data = mtcars[,1:7], annotation=mtcars[,8:11], center = TRUE, scale. = TRUE)
b <- eruptionPlot(model = a, factor=mtcars[,"vs"], optns=list(plotTitle = "mtcars eruption", method = "bonferroni", PC=2))

b[["plots"]][["eruptionPlot"]]
```


#cliffs delta
```{r}

df <- a$data$rawData
df$factor <- as.numeric(as.factor(BIOspcglyc[,"covid_status"]))

wilcox.test(SPC_All ~ factor, data = df)

U <- list()
for(i in 1:(ncol(df)-1)){
  formula <- as.formula(paste(colnames(df)[i]," ~ factor", sep=""))
  model <- wilcox.test(formula, data = df)
  U[[i]] <- model[["statistic"]]
}

   n <- table(df$factor)[1]
   m <- table(df$factor)[2]

U <- (unlist(U))

cd <- (U/(n*m)-0.5)*2 

tt<-subset(a$data$rawData, select=-c(factor))

colnames(subset(a$data$rawData, select=-c(factor)))
rbind(colnames(subset(a$data$rawData, select=-c(factor))), cd)


d<-eruptionPlot(model = a, factor=BIOspcglyc[,"covid_status"])

rescale.factor = (n*m-1)/(n*m)
idx<- which(df[,"factor"]==1)
control <- df[idx,]
treatment <- df[-idx,]

tc<-list(control, treatment)






control<-sort(control)
treatment<-sort(treatment)


dominance = sign(outer(treatment, control, FUN="-"))
row.names(dominance) = treatment
colnames(dominance) = control

d = mean(dominance)

d. = ifelse(abs(d)==1,d*rescale.factor,d)

return(d.)

tc<-list(df[which(factor==1),1], df[which(factor==2),1])   
tc<-list(mod@X[which(Y==1),1],mod@X[which(Y==0),1])

c<-list()
for(i in 1:(ncol(control)-1)){
  c[[i]] <- sort(control[,i])
}

t<-list()
for(i in 1:(ncol(treatment)-1)){
  t[[i]] <- sort(treatment[,i])
}

d<-list()
for(i in 1:(ncol(df)-1)){
d[[i]] <-sign(outer(t[[i]], c[[i]], FUN="-"))
}

dd<-list()
for(i in 1:(ncol(df)-1)){
dd[[i]]<-mean(d[[i]])
}
#0.5393317

rescale.factor = (n*m-1)/(n*m)
for(i in 1:(ncol(df)-1)){
ifelse(test = abs(dd[[i]])==1, yes = dd[[i]]*rescale.factor, no=dd)
}

unlist(dd)



sort(control[,1])
c[i]= tc[[2]]
treatment = tc[[1]]
control<-sort(control)
treatment<-sort(treatment)
n1 = length(treatment)
n2 = length(control)
rescale.factor = (n1*n2-1)/(n1*n2)

dominance = sign(outer(treatment, control, FUN="-")) 
row.names(dominance) = treatment
colnames(dominance) = control

d = mean(dominance)

```
```{r}
idx<-which(df$factor==1)
idy<-which(df$factor==2)
x<-df[idx,]
y<-df[idy,]

pval<-kruskal.test(df$SPC_All,df$factor)$p.value

p.adjust(pval, method="bonferroni")

abs(log10(pval))


pval<-list()
for(i in 1:(ncol(df)-1)){
pval[[i]]<-kruskal.test(df[,i],df[,"factor"])$p.value  
}

unlist(pval)
pvalAdjusted <- p.adjust(pval, method="bonferroni")
pvalRescaled <- abs(log10(pvalAdjusted))
loading<-as.data.frame(a$data$loadings[,1])
id<-as.data.frame(row.names(loading))

dd<-t(as.data.frame(dd))
pvalRescaled<-as.data.frame(pvalRescaled)

ed<-cbind(dd,pvalRescaled,loading[,1], id)

colnames(ed)<-c("cd", "pvalRescaled", "PC1 loadings", "id")

class(ed)

ggplot(ed, aes(x = ed$cd,  y = ed$`PC1 loadings`, color=pvalRescaled)) + 
geom_label_repel(aes(label = id), 
                   colour = "black",
                 min.segment.length = 0.001)+
  geom_point(size = 3,
             shape = 1) +
  geom_point(size = 3,
             shape = 16,
             alpha = 0.3) +
  theme_bw() +
  scale_x_continuous(limits = c(-1, 1)) +
  scale_colour_gradientn(colours = rainbow(7)) +
  labs(x = "Cliff's Delta",
       y = "PC1 Loadings") +
  theme(panel.grid.minor = element_blank(),
        plot.tag = element_text(face = "bold",
                                size = 25),
        legend.position = "top",
        legend.direction = "horizontal")


Xsc<-a$data$dataSC
scores <- a$data$scores[,1]
corr<-cor(a$data$scores[,1], a$data$dataSC)

```

#tests plotLoadingsGrid
```{r}
p2<- plotLoadingGrid(screeCumulativeThresholdObject = b, gridTitle = "Loadings")
```
#multiplot (works with grids)
```{r}
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

a1<-pcaGrid(screeCumulativeThresholdObject = b, CO = "covid_status", COtitle = "covid")

a3 <-pcaGrid(screeCumulativeThresholdObject = b, CO = "covid_status", SZ = "age", AL = "bmi", COtitle = "Covid", SZtitle = "Age", ALtitle = "BMI")

a2 <- pcaGrid(screeCumulativeThresholdObject = b, CO = "covid_status", SZ = 5, COtitle = "covid", SZtitle = "Age")
multiplot(plotlist = list(p1, p2))
```


#combined scree and cumulative plot
```{r}

ttt <- function(pcResultsObject, cutoff = 99){

  a <- pcResultsObject
  #t <- length(which(a$pcSum$`Cumulative Proportion` < cutoff))

#Make cumulative variance plot

# Plotting Charts and adding a secondary axis

ggp <- ggplot(a$pcSum)  + 
  geom_bar(aes(x=`rowname`, y=`Proportion of Variance`),stat="identity", fill="grey20",colour="black", alpha = 0.4)+
  geom_line(aes(x=`rowname`, y=`Cumulative Proportion`),stat="identity",color="orange2",size=2, group = 1)+
  labs(title= "Screeplot and Cumulative Variance",
       x = "PC",y = "Cumulative Variance (%)")+
  scale_y_continuous(sec.axis = sec_axis(~.*0.5, name = "Proportion of Variance (%)"))+
  theme(
    axis.title.y = element_text(color = "gray30"),
    axis.title.y.right = element_text(color = "orange3")
  )
ggp
   
return(cumulativeVariance)
}
ttt(pcResultsObject = a)
```

#legend back up don't touch
```{r}
pcagridlegend<-function(screecumulativethresholdobject, x = "PC1", y = "PC2", CO, SH, AL, SZ, COtitle, SHtitle, SZtitle, ALtitle){
  
  output <- plotInput(screecumulativethresholdobject, CO, SH, SZ, AL)
  # Get required data for plotting
  
  gu <- if(class(SH) == "character" & class(SZ) == "numeric" & class(AL) == "numeric") {
    guides(alpha = "none", size = "none")
  } else if (class(SH) == "NULL" & class(SZ) == "character" & class(AL) == "numeric") {
    guides(alpha = "none", shape = "none")
  } else if (class(SH) == "NULL" & class(SZ) == "numeric" & class(AL) == "character") {
    guides(shape = "none", size = "none")
  } else if (class(SH) == "character" & class(SZ) == "character" & class(AL) == "numeric") {
    guides(alpha = "none" )
  } else if (class(SH) == "character" & class(SZ) == "numeric" & class(AL) == "character") {
    guides(size = "none")
  } else if (class(SH) == "NULL" & class(SZ) == "character" & class(AL) == "character") {
    guides(shape = "none")
  } else if (class(SH) == "character" & class(SZ) == "character" & class(AL) == "character") {
    guides()
  } else if (class(SH) == "NULL" & class(SZ) == "numeric" & class(AL) == "numeric") {
    guides(shape = "none", size = "none", alpha = "none")
  }
  
  test <- ggplot(data = output$data$pcdf, aes(x = .data[[x]], y = .data[[y]], color = output$CO, shape = output$SH, alpha = output$AL, size = output$SZ)) +
    geom_point() +
    gu +
    # scale_fill_manual(values=c('red','blue','green','red','blue')) +
    # scale_colour_manual(values=c('red','blue','green','red','blue')) +
    scale_color_brewer(palette = "Set2") +
    labs(color = COtitle, shape = SHtitle, size = SZtitle, alpha = ALtitle ) +
    theme_minimal()
  return(test)
}

test <- pcagridlegend(screecumulativethresholdobject = b, x = "PC1", y = "PC2", CO = "covid_status", SH="sex", AL="age", SZ=0.1, COtitle = "COV", SHtitle= "gender", SZtitle=NULL, ALtitle="Age")
```

#working my_fn1, don't touch 
```{r}
  my_fn1 <- function(data, mapping, method="stat_ellipse"){
    p <- ggplot(data = data, mapping = mapping) +
    #  geom_point() +
    # geom_point(aes(color = .data[[colour]], shape = output$SH, size=output$SZ, alpha=output$AL)) +
    # stat_ellipse(aes(group=interaction(.data[[colour]], color=.data[[colour]]), color=.data[[colour]]))+
    theme_minimal()+
    geom_hline(yintercept=0, linetype="dashed", color = "black")+
    geom_vline(xintercept=0, linetype="dashed", colour= "black")
  return(p)
}

pcagrid <-function(screecumulativethresholdobject, CO, SH, SZ, AL){

  output <- plotinput(screecumulativethresholdobject, CO, SH, SZ, AL)
  thresh <- output$data$treshold
  #   my_fn1 <- function(data, mapping, method="stat_ellipse"){
  #   p <- ggplot(data = output$data$pcdf, mapping=mapping) +
  #     geom_point(aes(color = .data[[colour]], shape = output$SH, size=output$SZ, alpha=output$AL)) +
  #     stat_ellipse(aes(group=interaction(.data[[colour]], color=.data[[colour]]), color=.data[[colour]]))+
  #     theme_minimal()+
  #     geom_hline(yintercept=0, linetype="dashed", color = "black")+
  #     geom_vline(xintercept=0, linetype="dashed", colour= "black")
  #   p
  # }

  title <- list()
  for (i in 1:thresh) {
    title[[i]] <- paste0('PC', i, ' (', round(output$data$explained_variance_ratio[i], 1), '%)')
  }
  title<-unlist(title)

  pcagridplot<-GGally::ggpairs(data = output$data$pcdf[,1:thresh],
                               columnLabels = c(title),
                               diag="blank",
                               upper="blank",
                               #upper=list(continuous = my_fn1),
                               lower=list(continuous = my_fn1),
                               #legend = grab_legend(test),
                               progress = F,
                               switch = "both") +
    geom_point(aes(colour = output$CO, shape = output$SH, size=output$SZ, alpha=output$AL)) +
    stat_ellipse(aes(group=interaction(output$CO, color=output$CO), color=output$CO))+
    theme_bw() +
    theme(strip.background = element_rect(fill = "white"),
          axis.text.x = (element_text(size=rel(0.7), angle=0)),
          axis.text.y = (element_text(size=rel(0.7), angle=0)),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(fill = NA,colour = "grey35"))
  pcagridplot

}
```
#working pcagrid, don't touch 
```{r}
pcagrid <-function(pcresultobject, colour, SH, SZ, AL){

  output <- pcresultobject
  #t <- 4
  thresh <- 4
    #as.numeric(output$data$treshold)

  # Get required data for plotting

  #shape
  SH <- if(class(SH) == "NULL") {
    SH = SH
  }else if(class(SH) == "character"){
    SH = output$pcdf[,SH]
  }
  #SH = output$pcdf$SH

  #size
  SZ <- if(class(SZ) == "numeric") {
    SZ = SZ
  }else if (class(SZ) == "character"){
    SZ = output$pcdf[,SZ]
  }
  #SZ = output$pcdf$SZ

  #alpha
  AL <- if(class(AL) == "numeric") {
    AL = AL
  }else if (class(AL) == "character"){
    AL = output$pcdf[,AL]
  }
  #AL = output$pcdf$AL


my_fn1 <- function(data, mapping, method="stat_ellipse"){
  p <- ggplot(data = df, mapping=mapping) + 
    geom_point(aes(color = .data[[colour]], shape = SH, size=SZ, alpha=AL)) + 
    stat_ellipse(aes(group=interaction(.data[[colour]], color=.data[[colour]]), color=.data[[colour]]))+
  theme_minimal()+
  geom_hline(yintercept=0, linetype="dashed", color = "black")+
  geom_vline(xintercept=0, linetype="dashed", colour= "black")
  p
} 

  # myfun <- ggplot(data = output$pcdf) +
  # #myfun <- ggplot(data = output$pcdf, mapping = mapping) +
  #   geom_point(aes(color = .data[[colour]], shape = SH, size = SZ, alpha = AL)) +
  #   stat_ellipse(aes(group = interaction(.data[[colour]], color = .data[[colour]]), color = .data[[colour]]))+
  #   theme_minimal()+
  #   geom_hline(yintercept = 0, linetype = "dashed", color = "black")+
  #   geom_vline(xintercept = 0, linetype = "dashed", color = "black")

  title <- list()
  for (i in 1:thresh) {
    title[[i]] <- paste0('PC', i, ' (', round(output$explained_variance_ratio[i], 1), '%)')
  }
  title<-unlist(title)

  pcagridplot<-GGally::ggpairs(output$pcdf[,1:thresh],
                         columnLabels = c(title),
                         diag="blank",
                         upper="blank",
                         #upper=list(continuous = my_fn1),
                         lower=list(continuous = my_fn1),
                         #legend = grab_legend(test),
                         progress = F,
                         switch = "both") +
                         theme_bw() +
                         theme(strip.background = element_rect(fill = "white"),
                                axis.text.x = (element_text(size=rel(0.7), angle=0)),
                                axis.text.y = (element_text(size=rel(0.7), angle=0)),
                                panel.grid.major = element_blank(),
                                panel.grid.minor = element_blank(),
                                panel.border = element_rect(fill = NA,colour = "grey35"))
  pcagridplot

}

pcagrid(pcresultobject = a, colour="covid_status", SH=NULL, SZ=1, AL=0.4)


# explained_variance_ratio(results = a)
# b<- pcsummary(results = a)
# t<- threshold(pcsum = b)
# screecumulativethreshold(pcsum = b, threshold = t)
# p<-pcdf(results = a, annotation = BIOspcglyc[,-1:-8])
# 
# 
# inputData <- plotinput(data = aaMeta1, SZ = aaMeta1$sex, SH = aaMeta1$age, AL = 0.4)
# 
# append(myList, item, after = index)
```
#working plotloadingsgrid
```{r}
results<-prcomp(BIOspcglyc[,1:8], center = TRUE, scale. = TRUE)
data<-cbind(as.data.frame(results[["x"]]), BIOspcglyc[,-1:-8])
summary(results)->for.scree
for.scree<-rownames_to_column(as.data.frame(t(for.scree$importance)))%>% mutate(across(where(is.double), ~.x*100))

df <- as.data.frame(results$rotation)
symmetric_limits <- function (x) 
{
    max <- max(abs(x))
    c(-max, max)
}

#functions to feed into ggpairs
my_fn2 <- function(data, mapping, ...){
  p <- ggplot(data = df, mapping = mapping) + 
    #geom_point() + 
    #geom_text(label=rownames(df), hjust=0, vjust=0, position=position_dodge(width=0.9))+
    scale_x_continuous(limits = symmetric_limits) +
  scale_y_continuous(limits = symmetric_limits) +
    #stat_ellipse(aes(group=interaction(df$covid_status, color=df$covid_status), color=df$covid_status))+
  theme_minimal()+
    theme(text = element_text(size = 3))+
  geom_hline(yintercept=0, linetype="dashed", color = "black")+
  geom_vline(xintercept=0, linetype="dashed", colour= "black")
  p
}  

##ggpairs plot with ellipses using ggpairs and predefined functions
t<-4
  
p1 <- GGally::ggpairs(df[,1:t],
columnLabels = c("PC1", "PC2", "PC3", "PC4"),
              diag="blank",
              upper="blank",
              #upper=list(continuous =my_fn1),
              lower=list(continuous =my_fn2),
#legend = TRUE, progress = F, switch="both") + 
#legend = grab_legend(test), 
progress = F, switch="both") + geom_point(color= "red", size = 0.5)+
  geom_text(aes(label = rownames(df)), size = 2, colour = "red", hjust=0, vjust=0)+
 theme_bw() + 
                  theme(strip.background = element_rect(fill = "white"),axis.text.x=(element_text(size=rel(0.7), angle=0)),
                  axis.text.y=(element_text(size=rel(0.7), angle=0)), panel.grid.major = element_blank(),
                  panel.grid.minor = element_blank(), panel.border = element_rect(fill = NA,colour = "grey35"))

p1

#try get rid of blanksquares
 gpairs_lower <- function(g){
  g$plots <- g$plots[-(1:g$nrow)]
  g$yAxisLabels <- g$yAxisLabels[-1]
  g$nrow <- g$nrow -1

  g$plots <- g$plots[-(seq(g$ncol, length(g$plots), by = g$ncol))]
  g$xAxisLabels <- g$xAxisLabels[-g$ncol]
  g$ncol <- g$ncol - 1

  g
}

(gpairs_lower(p1))
 
```
#kmeans cluster
```{r}
library(FactoMineR)
library(factoextra)
library(stats)

#1) create pcresults object
a <- pcResults(BIOspcglyc[,1:8], annotation = BIOspcglyc[,-1:-8])

#2) determine number of clusters
fviz_nbclust(a$pcdf[,1:2], FUNcluster = kmeans, method="wss", verbose = FALSE, print.summary = TRUE)

#3) calculate clusters
set.seed(123)
trial <- kmeans(x = a$pcdf[,1:2], centers = 4, nstart = 1)

#4) visualize clusters
fviz_cluster(object = trial, data = a$pcdf[,1:2])
```
```{r}
trial <- kmeans(x = a$pcdf[,1:8], centers = 4, nstart = 25)
fviz_cluster(object = trial, data = a$pcdf[,1:8])
```

```{r}

library(ggforce)
pcaHotelGrid <-function(screeCumulativeThresholdObject, CO, SH = NULL, SZ = 1, AL = 0.5, COtitle, SHtitle = "NULL", SZtitle = "NULL", ALtitle = "NULL", gridTitle = "PCA Grid"){

  output <- plotInput(screeCumulativeThresholdObject, CO, SH, SZ, AL)
  thresh <- 6
  test <- pcaGridLegend(screeCumulativeThresholdObject, x = "PC1", y = "PC2", CO, SH, AL, SZ, COtitle, SHtitle, SZtitle, ALtitle)

  myFn3 <- function(data, mapping, method="geom_ellipse"){
    p <- ggplot(data = data, mapping = mapping) +
      theme_minimal() +
      geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
      geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
      scale_color_brewer(palette = "Set2")
    return(p)
  } 

#Loop for creating titles of "PC(explained variance %)"

  title <- list()
  for (i in 1:thresh) {
    title[[i]] <- paste0('PC', i, ' (', round(output$data$pcSum$`Proportion of Variance`[i], 1), '%)')
  }
  title<-unlist(title)

#combinations for which aesthetics are set to a variable and those set to a single value. Colour is always defined by a variable.

  gp <- if(class(SH) == "character" & class(SZ) == "numeric" & class(AL) == "numeric") {
          geom_point(aes(colour = output$CO, shape = output$SH), size = output$SZ, alpha = output$AL)
        } else if (class(SH) == "NULL" & class(SZ) == "character" & class(AL) == "numeric") {
          geom_point(aes(colour = output$CO, size = output$SZ), shape = output$SH, alpha = output$AL)
        } else if (class(SH) == "NULL" & class(SZ) == "numeric" & class(AL) == "character") {
          geom_point(aes(colour = output$CO, alpha = output$AL), shape = output$SH, size = output$SZ)
        } else if (class(SH) == "character" & class(SZ) == "character" & class(AL) == "numeric") {
          geom_point(aes(colour = output$CO, shape = output$SH, size = output$SZ), alpha = output$AL)
        } else if (class(SH) == "character" & class(SZ) == "numeric" & class(AL) == "character") {
          geom_point(aes(colour = output$CO, shape = output$SH, alpha = output$AL), size = output$SZ)
        } else if (class(SH) == "NULL" & class(SZ) == "character" & class(AL) == "character") {
          geom_point(aes(colour = output$CO, size = output$SZ, alpha = output$AL), shape = output$SH)
        } else if (class(SH) == "character" & class(SZ) == "character" & class(AL) == "character") {
          geom_point(aes(colour = output$CO, shape = output$SH, size = output$SZ, alpha = output$AL))
        } else if (class(SH) == "NULL" & class(SZ) == "numeric" & class(AL) == "numeric") {
          geom_point(aes(colour = output$CO), shape = output$SH, size = output$SZ, alpha = output$AL)
        }

#create the PCA grid
  gridTitle = gridTitle

  pcaHotelPlot<-GGally::ggpairs(data = output$data$pcdf[,1:thresh],
                               columnLabels = c(title),
                               title = gridTitle,
                               diag="blank",
                               upper="blank",
                               #upper=list(continuous = my_fn1),
                               lower=list(continuous = myFn3),
                               legend = grab_legend(test),
                               progress = F,
                               switch = "both") +
                               gp +
                               #geom_ellipse(aes(x0 = 0, y0 = 0, a = a2, b = b2, angle = 0), size = .5, linetype = "dashed") +
                  stat_ellipse( type = "t", geom = "polygon", fill = "gray", level = 0.95, alpha = .5, linetype = 2)+
                               #stat_ellipse(aes(group=interaction(output$CO, color=output$CO), color=output$CO))+
                               theme_bw() +
                               theme(strip.background = element_rect(fill = "white"),
                               axis.text.x = (element_text(size=rel(0.7), angle=0)),
                               axis.text.y = (element_text(size=rel(0.7), angle=0)),
                               panel.grid.major = element_blank(),
                               panel.grid.minor = element_blank(),
                               panel.border = element_rect(fill = NA,colour = "grey35"))


#calculate hotelling's

for(x in 1:thresh)
{
  for(y in 1:thresh)
  {
    if(y > x)
    {
      eliRes <- ellipseParam(data = output$data$pcdf[,1:thresh], k = 2, pcx = x, pcy = y)
      aVal <- pluck(eliRes, "Ellipse", "a.95pct")
      bVal <- pluck(eliRes, "Ellipse", "b.95pct")
      temp <- pcaHotelPlot[y, x]
      temp <- temp + geom_ellipse(aes(x0 = 0, y0 = 0, a = eliRes$Ellipse$`a.95pct`, b = eliRes$Ellipse$`b.95pct`, angle = 0), size = .5, linetype = "dashed")
      pcaHotelPlot[y, x] <- temp}
  }
}
  
# #What I want to loop:
# res1.2 <- ellipseParam(data = a$pcdf[,1:thresh], k = 2, pcx = 1, pcy = 2)
# #We can extract parameters for further use:
#   # Semi-axes of the ellipse at 95% confidence level.
# a1.2 <- pluck(res1.2, "Ellipse", "a.95pct")
# b1.2 <- pluck(res1.2, "Ellipse", "b.95pct")
# #
# # #add ellipses
# p1.2<-pcaHotelPlot[2,1]
# p1.2 <- p1.2 + geom_ellipse(aes(x0 = 0, y0 = 0, a = a1.2, b = b1.2, angle = 0), size = .5, linetype = "dashed")
# pcaHotelPlot[2,1] <- p1.2
# 
# 
# res1.3 <- ellipseParam(data = a$pcdf[,1:thresh], k = 2, pcx = 1, pcy = 3)
# #We can extract parameters for further use:
#   # Semi-axes of the ellipse at 95% confidence level.
# a1.3 <- pluck(res1.3, "Ellipse", "a.95pct")
# b1.3 <- pluck(res1.3, "Ellipse", "b.95pct")
# #
# # #add ellipses
# p1.3<-pcaHotelPlot[3,1]
# p1.3 <- p1.3 + geom_ellipse(aes(x0 = 0, y0 = 0, a = a1.3, b = b1.3, angle = 0), size = .5, linetype = "dashed")
# pcaHotelPlot[3,1] <- p1.3
# 
# res2.3 <- ellipseParam(data = a$pcdf[,1:thresh], k = 2, pcx = 2, pcy = 3)
# #We can extract parameters for further use:
#   # Semi-axes of the ellipse at 95% confidence level.
# a2.3 <- pluck(res2.3, "Ellipse", "a.95pct")
# b2.3 <- pluck(res2.3, "Ellipse", "b.95pct")
# #
# # #add ellipses
# p2.3<-pcaHotelPlot[3, 2]
# p2.3 <- p2.3 + geom_ellipse(aes(x0 = 0, y0 = 0, a = a2.3, b = b2.3, angle = 0), size = .5, linetype = "dashed")
# pcaHotelPlot[3,2] <- p2.3

#remove empty grid spaces (lower and diagonal)

  final_plot <- gPairsLower(pcaHotelPlot)
  return(final_plot)
}
(pcaHotelGrid(screeCumulativeThresholdObject = b, CO = "covid_status", COtitle = "Covid"))
```

```{r}
pluck((ellipseParam(data = a$pcdf[,1:7], k = 2, pcx = 1, pcy = 3)), "Ellipse", "b.95pct")
pluck((ellipseParam(data = a$pcdf[,1:7], k = 2, pcx = 4, pcy = 2)), "Ellipse", "b.95pct")

# a95<- matrix(nrow=4, ncol=4)
# for(i in 1:Thresh){
#   for(j in Thresh:1){
# a95[i,j]<-pluck((ellipseParam(data = a$pcdf[,1:Thresh], k = 2, pcx = i, pcy = j)), "Ellipse", "a.95pct")
#   }
# }

for(x in 1:Thresh)
{
  for(y in 1:Thresh)
  {
    if(y>x)
    {
      eliRes <- ellipseParam(data = a$pcdf[,1:Thresh], k = 2, pcx = x, pcy = y)
      
      temp <- pcHotelPlot[y, x]
      temp <- temp + geom_ellipse(aes(x0 = 0, y0 = 0, a = eliRes$Ellipse$a.95pct, b = eliRes$Ellipse$b95pct, angle = 0), size = .5, linetype = "dashed")
      pcHotelPlot[y, x] <- temp

#       p1.3<-pcaHotelPlot[3,1]
# p1.3 <- p1.3 + geom_ellipse(aes(x0 = 0, y0 = 0, a = a1.3, b = b1.3, angle = 0), size = .5, linetype = "dashed")
# pcaHotelPlot[3,1] <- p1.3  
    }
  }
}

a95<- matrix(nrow=4, ncol=4)
for(i in 1:Thresh){
  for(j in Thresh:1){
    if(i==j){
      a95[i,j] <- 0
    }else if(i!=j){
a95[i,j]<-pluck((ellipseParam(data = a$pcdf[,1:Thresh], k = 2, pcx = i, pcy = j)), "Ellipse", "a.95pct")
    }
    }
}

b95<- matrix(nrow=4, ncol=4)
for(i in 1:Thresh){
  for(j in Thresh:1){
    if(i==j){
      b95[i,j] <- 0
    }else if(i!=j){
b95[i,j]<-pluck((ellipseParam(data = a$pcdf[,1:Thresh], k = 2, pcx = i, pcy = j)), "Ellipse", "b.95pct")
    }
    }
}

#add ellipses
p1.3<-pcaHotelPlot[3,1]
p1.3 <- p1.3 + geom_ellipse(aes(x0 = 0, y0 = 0, a = a1.3, b = b1.3, angle = 0), size = .5, linetype = "dashed")
pcaHotelPlot[3,1] <- p1.3  
  
# b95<- list()
# for(i in 2:Thresh){
# b95[[i]]<- pluck((ellipseParam(data = a$pcdf[,1:i], k = 2, pcx = 1, pcy = i)), "Ellipse", "b.95pct")
# }
# 
# b952<- list()
# for(i in 3:Thresh){
# b952[[i]]<- pluck((ellipseParam(data = a$pcdf[,1:i], k = 2, pcx = 2, pcy = i)), "Ellipse", "b.95pct")
# }
```

```{r}
pm <- ggpairs(tips, columns = c("total_bill", "time", "tip"))

p <- pm[3,1]
p <- p + aes(color = time)
p

pm[3,1] <- p
pm


res <- ellipseParam(data = a$pcdf[,1:3], k = 2, pcx = 1, pcy = 3)

#We can extract parameters for further use:
  # Semi-axes of the ellipse at 95% confidence level.
a2 <- pluck(res, "Ellipse", "a.95pct")
b2 <- pluck(res, "Ellipse", "b.95pct")

pm[1,3] + geom_ellipse(aes(x0 = 0, y0 = 0, a = a2, b = b2, angle = 0), size = .5, linetype = "dashed") 

class(res)
```


```{r}
ellipseCoord <- function(data, pcx = 1, pcy = 2, conf.limit = 0.95, pts = 200) {
  
  # matrix of data
  X <- as.matrix(data)
  
  # Sample size
  n <- nrow(X)
  
  # Confidence limit
  alpha <- as.numeric(conf.limit)
  
  # Number of points
  m <- as.numeric(pts)
  p <- seq(0, 2*pi, length.out = m)
  
  # # Hotelling’s T-square limit
  Tsq_limit <- (2*(n-1)/(n-2))*stats::qf(p = alpha, df1 = 2, df2 = (n-2))
  
  # Coordinate points
  rx <- sqrt(Tsq_limit*stats::var(X[, pcx]))
  ry <- sqrt(Tsq_limit*stats::var(X[, pcy]))
  
  #coordinates
  res.coord <- tibble::tibble(
    x = rx*cos(p) + mean(X[, pcx], na.rm = TRUE),
    y = ry*sin(p) + mean(X[, pcy], na.rm = TRUE)
  )
  
  return(res.coord)
}
el<-ellipseCoord (data = a$pcdf[,1:2], pcx = 1, pcy = 2, conf.limit = 0.95, pts = 200)




gg_circle <- function(rx, ry, xc, yc, color = "black", fill = NA, ...) {
  x <- xc + rx * cos(seq(0, pi, length.out = 100))
  ymax <- yc + ry * sin(seq(0, pi, length.out = 100))
  ymin <- yc + ry * sin(seq(0, -pi, length.out = 100))
  annotate(
    "ribbon",
    x = x, ymin = ymin, ymax = ymax,
    color = color, fill = fill, ...
  )
}

 X <- as.matrix(a$pcdf)
  
  # Sample size
  n <- nrow(X)

 hotFisN <- (n - 1) * 2 * (n^2 - 1) / (n^2 * (n - 2)) * qf(0.95, 2, n - 2)
 

p <- ggplot(data=a$pcdf, aes(x=a$pcdf$PC4, y=a$pcdf$PC5)) +
  geom_point() +
  #stat_ellipse( type = "norm", geom = "polygon", fill = "gray", level = 0.95, alpha = .5, linetype = 2)
  #geom_point(aes(colour= a$pcdf$covid_status)) +
   gg_circle(
    rx = sqrt(var(a$pcdf$PC4) * hotFisN),
    ry = sqrt(var(a$pcdf$PC5) * hotFisN),
    xc = 0, yc = 0
  )

ggplotly(p)

#outliers
rx = sqrt(var(a$pcdf$PC4) * hotFisN)
ry = sqrt(var(a$pcdf$PC5) * hotFisN)

insideOut <-list( (a$pcdf$PC4^2)/(rx^2) + (a$pcdf$PC5^2)/(ry^2))
idx <-which(insideOut[[1]] > 1)
#idx gives  6  13  19  29 104 105 111 117 119 127
outlierTest <- a$pcdf[idx,]

p + geom_text(data=outlierTest,
            aes(x = outlierTest$PC4,y=outlierTest$PC5, label = outlierTest$sampleID))


                       
# Load packages
# library(ggplot2)
# library(sp)
# 
# # Build the plot first
# p <- ggplot(faithful, aes(waiting, eruptions)) +
#   geom_point() +
#   stat_ellipse()

# Extract components
build2 <- ggplot_build(p)$data
points2 <- build2[[1]]
ell2 <- build2[[2]]

# Find which points are inside the ellipse, and add this to the data
dat <- data.frame(
  points[1:2], 
  in.ell2 = as.logical(point.in.polygon(points2$x, points2$y, ell2$x, ell2$y))
)

# Plot the result
ggplot(dat, aes(x, y)) +
  geom_point(aes(col = in.ell)) +
  stat_ellipse()
  
```
#ggcircle
```{r}
library(ggforce)
pcaHotelGrid <-function(screeCumulativeThresholdObject, CO, SH = NULL, SZ = 1, AL = 0.5, COtitle, SHtitle = "NULL", SZtitle = "NULL", ALtitle = "NULL", gridTitle = "PCA Grid"){

  output <- plotInput(screeCumulativeThresholdObject, CO, SH, SZ, AL)
  thresh <- 3
  # thresh <- output$data$threshold
  test <- pcaGridLegend(screeCumulativeThresholdObject, x = "PC1", y = "PC2", CO, SH, AL, SZ, COtitle, SHtitle, SZtitle, ALtitle)

  myFn3 <- function(data, mapping, method="stat_ellipse"){
    p <- ggplot(data = data, mapping = mapping) +
      theme_minimal() +
      geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
      geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
      scale_color_brewer(palette = "Set2")
    return(p)
  } 

#Loop for creating titles of "PC(explained variance %)"

  title <- list()
  for (i in 1:thresh) {
    title[[i]] <- paste0('PC', i, ' (', round(output$data$pcSum$`Proportion of Variance`[i], 1), '%)')
  }
  title<-unlist(title)

#combinations for which aesthetics are set to a variable and those set to a single value. Colour is always defined by a variable.

  gp <- if(class(SH) == "character" & class(SZ) == "numeric" & class(AL) == "numeric") {
          geom_point(aes(colour = output$CO, shape = output$SH), size = output$SZ, alpha = output$AL)
        } else if (class(SH) == "NULL" & class(SZ) == "character" & class(AL) == "numeric") {
          geom_point(aes(colour = output$CO, size = output$SZ), shape = output$SH, alpha = output$AL)
        } else if (class(SH) == "NULL" & class(SZ) == "numeric" & class(AL) == "character") {
          geom_point(aes(colour = output$CO, alpha = output$AL), shape = output$SH, size = output$SZ)
        } else if (class(SH) == "character" & class(SZ) == "character" & class(AL) == "numeric") {
          geom_point(aes(colour = output$CO, shape = output$SH, size = output$SZ), alpha = output$AL)
        } else if (class(SH) == "character" & class(SZ) == "numeric" & class(AL) == "character") {
          geom_point(aes(colour = output$CO, shape = output$SH, alpha = output$AL), size = output$SZ)
        } else if (class(SH) == "NULL" & class(SZ) == "character" & class(AL) == "character") {
          geom_point(aes(colour = output$CO, size = output$SZ, alpha = output$AL), shape = output$SH)
        } else if (class(SH) == "character" & class(SZ) == "character" & class(AL) == "character") {
          geom_point(aes(colour = output$CO, shape = output$SH, size = output$SZ, alpha = output$AL))
        } else if (class(SH) == "NULL" & class(SZ) == "numeric" & class(AL) == "numeric") {
          geom_point(aes(colour = output$CO), shape = output$SH, size = output$SZ, alpha = output$AL)
        }

#create the PCA grid
  gridTitle = gridTitle

  pcaHotelPlot<-GGally::ggpairs(data = output$data$pcdf[,1:thresh],
                               columnLabels = c(title),
                               title = gridTitle,
                               diag="blank",
                               upper="blank",
                               #upper=list(continuous = my_fn1),
                               lower=list(continuous = myFn3),
                               legend = grab_legend(test),
                               progress = F,
                               switch = "both") +
                               gp +
                               #stat_ellipse(aes(group=interaction(output$CO, color=output$CO), color=output$CO))+
                               theme_bw() +
                               theme(strip.background = element_rect(fill = "white"),
                               axis.text.x = (element_text(size=rel(0.7), angle=0)),
                               axis.text.y = (element_text(size=rel(0.7), angle=0)),
                               panel.grid.major = element_blank(),
                               panel.grid.minor = element_blank(),
                               panel.border = element_rect(fill = NA,colour = "grey35"))


#calculate hotelling's
gg_circle <- function(rx, ry, xc, yc, color = "black", fill = NA, ...) {
  x <- xc + rx * cos(seq(0, pi, length.out = 100))
  ymax <- yc + ry * sin(seq(0, pi, length.out = 100))
  ymin <- yc + ry * sin(seq(0, -pi, length.out = 100))
  annotate(
    "ribbon",
    x = x, ymin = ymin, ymax = ymax,
    color = color, fill = fill, ...
  )
}

 X <- as.matrix(output$data$pcdf)
  
  # Sample size
  n <- nrow(X)

 hotFisN <- (n - 1) * 2 * (n^2 - 1) / (n^2 * (n - 2)) * qf(0.95, 2, n - 2)
 
 ellipseStat <- FALSE
 hotelStat <- TRUE
 ellipseStat2 <- FALSE
 
for(i in 1:thresh)
{
  for(j in 1:thresh)
  {
    if(j>i)
    {
      temp <- pcaHotelPlot[j, i]
      if(hotelStat == TRUE){
      temp <- temp + gg_circle(rx = sqrt(var(output$data$pcdf[i]) * hotFisN),
                              ry = sqrt(var(output$data$pcdf[j]) * hotFisN),
                              xc = 0, yc = 0)
      }
      
      if(ellipseStat == TRUE){
              temp <- temp + stat_ellipse(aes(group=interaction(output$CO, color=output$CO), color=output$CO))
      }
      
      if(ellipseStat2 == TRUE){
        temp <- temp + stat_ellipse( type = "norm", geom = "polygon", fill = "gray", level = 0.95, alpha = .5, linetype = 2)
      }
      
      pcaHotelPlot[j, i] <- temp}}}


 # Extract components
build <- ggplot_build(pcaHotelPlot)$data
points <- build[[1]]
ell <- build[[2]]

 # Find which points are inside the ellipse, and add this to the data
dat <- data.frame(
  points[1:2],
  in.ell = as.logical(point.in.polygon(points$x, points$y, ell$x, ell$y))
)

#remove empty grid spaces (lower and diagonal)

  final_plot <- gPairsLower(pcaHotelPlot)
  return(final_plot)
}
(pcaHotelGrid(screeCumulativeThresholdObject = a, CO = "covid_status", COtitle = "Covid"))
```
#stat_ellipse not hotelling's
```{r}

library(ggforce)
pcaHotelGrid <-function(screeCumulativeThresholdObject, CO, SH = NULL, SZ = 1, AL = 0.5, COtitle, SHtitle = "NULL", SZtitle = "NULL", ALtitle = "NULL", gridTitle = "PCA Grid"){

  output <- plotInput(screeCumulativeThresholdObject, CO, SH, SZ, AL)
  thresh <- 3
  test <- pcaGridLegend(screeCumulativeThresholdObject, x = "PC1", y = "PC2", CO, SH, AL, SZ, COtitle, SHtitle, SZtitle, ALtitle)

  myFn3 <- function(data, mapping, method="geom_ellipse"){
    p <- ggplot(data = data, mapping = mapping) +
      theme_minimal() +
      geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
      geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
      scale_color_brewer(palette = "Set2")
    return(p)
  } 

#Loop for creating titles of "PC(explained variance %)"

  title <- list()
  for (i in 1:thresh) {
    title[[i]] <- paste0('PC', i, ' (', round(output$data$pcSum$`Proportion of Variance`[i], 1), '%)')
  }
  title<-unlist(title)

#combinations for which aesthetics are set to a variable and those set to a single value. Colour is always defined by a variable.

  gp <- if(class(SH) == "character" & class(SZ) == "numeric" & class(AL) == "numeric") {
          geom_point(aes(colour = output$CO, shape = output$SH), size = output$SZ, alpha = output$AL)
        } else if (class(SH) == "NULL" & class(SZ) == "character" & class(AL) == "numeric") {
          geom_point(aes(colour = output$CO, size = output$SZ), shape = output$SH, alpha = output$AL)
        } else if (class(SH) == "NULL" & class(SZ) == "numeric" & class(AL) == "character") {
          geom_point(aes(colour = output$CO, alpha = output$AL), shape = output$SH, size = output$SZ)
        } else if (class(SH) == "character" & class(SZ) == "character" & class(AL) == "numeric") {
          geom_point(aes(colour = output$CO, shape = output$SH, size = output$SZ), alpha = output$AL)
        } else if (class(SH) == "character" & class(SZ) == "numeric" & class(AL) == "character") {
          geom_point(aes(colour = output$CO, shape = output$SH, alpha = output$AL), size = output$SZ)
        } else if (class(SH) == "NULL" & class(SZ) == "character" & class(AL) == "character") {
          geom_point(aes(colour = output$CO, size = output$SZ, alpha = output$AL), shape = output$SH)
        } else if (class(SH) == "character" & class(SZ) == "character" & class(AL) == "character") {
          geom_point(aes(colour = output$CO, shape = output$SH, size = output$SZ, alpha = output$AL))
        } else if (class(SH) == "NULL" & class(SZ) == "numeric" & class(AL) == "numeric") {
          geom_point(aes(colour = output$CO), shape = output$SH, size = output$SZ, alpha = output$AL)
        }

#create the PCA grid
  gridTitle = gridTitle

  pcaHotelPlot<-GGally::ggpairs(data = output$data$pcdf[,1:thresh],
                               columnLabels = c(title),
                               title = gridTitle,
                               diag="blank",
                               upper="blank",
                               #upper=list(continuous = my_fn1),
                               lower=list(continuous = myFn3),
                               legend = grab_legend(test),
                               progress = F,
                               switch = "both") +
                               gp +
                               #geom_ellipse(aes(x0 = 0, y0 = 0, a = a2, b = b2, angle = 0), size = .5, linetype = "dashed") +
                  #stat_ellipse( type = "t", geom = "polygon", fill = "gray", level = 0.95, alpha = .5, linetype = 2)+
                               #stat_ellipse(aes(group=interaction(output$CO, color=output$CO), color=output$CO))+
                               theme_bw() +
                               theme(strip.background = element_rect(fill = "white"),
                               axis.text.x = (element_text(size=rel(0.7), angle=0)),
                               axis.text.y = (element_text(size=rel(0.7), angle=0)),
                               panel.grid.major = element_blank(),
                               panel.grid.minor = element_blank(),
                               panel.border = element_rect(fill = NA,colour = "grey35"))

#remove empty grid spaces (lower and diagonal)

  final_plot <- gPairsLower(pcaHotelPlot)
  return(final_plot)
}
(pcaHotelGrid(screeCumulativeThresholdObject = a
              , CO = "covid_status", COtitle = "Covid"))
```
#single working example of a PCA with outlier labels 
```{r}
 X <- as.matrix(a$pcdf)
  
  # Sample size
  n <- nrow(X)

 hotFisN <- (n - 1) * 2 * (n^2 - 1) / (n^2 * (n - 2)) * qf(0.95, 2, n - 2)
 
a$data$pcdf$CO<- rep_len("red", nrow(a$data$pcdf))
idx<- which(BIOspcglyc[,"covid_status"]=="covid")
 p <- ggplot(data=a$data$pcdf, aes(x=a$data$pcdf$PC1, y=a$data$pcdf$PC2)) +
  geom_point(aes(shape=a$data$pcdf$sex, color=a$data$pcdf$CO))
  #scale_color_brewer(palette = "Set2")+
  stat_ellipse( type = "t", geom = "polygon", fill = "gray", level = 0.95, alpha = .5, linetype = 2)
   #geom_text(aes(label = a$pcdf$patientID), size=2, hjust = 0, vjust = 0)

   gg_circle(
    rx = sqrt(var(a$pcdf$PC4) * hotFisN),
    ry = sqrt(var(a$pcdf$PC5) * hotFisN),
    xc = 0, yc = 0
  )

ggplotly(p)

#outliers
rx = sqrt(var(a$pcdf$PC4) * hotFisN)
ry = sqrt(var(a$pcdf$PC5) * hotFisN)


insideOut <-list((a$pcdf$PC4^2)/(rx^2) + (a$pcdf$PC5^2)/(ry^2))

a$pcdf$outlier <- ((a$pcdf$PC4^2)/(rx^2) + (a$pcdf$PC5^2)/(ry^2))
a$pcdf$outlier

idx <-(which(insideOut[[1]] > 1))
#idx gives  6  13  19  29 104 105 111 117 119 127
outlierTest <- a$pcdf[idx,]

p + geom_text(data=outlierTest,
            aes(x = outlierTest$PC4,y=outlierTest$PC5, label = outlierTest$sampleID))

p + geom_text(aes(label=ifelse(outlier>1,as.character(sampleID),'')),hjust=0,vjust=0)

p + geom_text(data=a$pcdf[idx,],aes(PC4, PC5,label="patientID"))

colourCode<-BIOspcglyc[,"covid_status"]
shapeCode <- BIOspcglyc[,"sex"]

colourCode<-rep_len("green", nrow(a$pcdf))
colourCode <-"green"

p <- ggplot(data=a$pcdf, aes(x=a$pcdf$PC4, y=a$pcdf$PC5)) +
  geom_point(aes(shape = shapeCode), colour=colourCode)

p <- ggplot(data=a$pcdf, aes(x=a$pcdf$PC4, y=a$pcdf$PC5)) +
  geom_point(aes(colour=colourCode,shape = shapeCode))
  

a$data$pcdf$CO<- rep_len("green", nrow(a$data$pcdf))

 p <- ggplot(data=a$data$pcdf, aes(x=a$data$pcdf$PC1, y=a$data$pcdf$PC2)) +
  geom_point(aes(shape=a$data$pcdf$sex, colour = (rep_len("green", nrow(a$data$pcdf)))))
p


p <- ggplot(data=a$data$pcdf, aes(x=a$data$pcdf$PC1, y=a$data$pcdf$PC2), color="green") +
  geom_point(aes(shape=a$data$pcdf$sex))
p
```
#cliffs delta
```{r}

BIOspcglyc$covid_status_factor<- as.numeric(factor(BIOspcglyc[,"covid_status"]))

idx <- which(BIOspcglyc$covid_status_factor==1)

control<- BIOspcglyc[idx,] %>%
  select("SPC1")
trial <- BIOspcglyc[-idx,] %>%
  select("SPC1")
#two tailed wilcoxon (allows for effect in two directions)
wt<-stats::wilcox.test(
  SPC_All ~ covid_status_factor, data=BIOspcglyc
)

wt[["statistic"]]
#3364

table(BIOspcglyc$covid_status)
#control   covid 
#   100      38 

((wt[["statistic"]])/(n*m)-0.5)*2
(3364/(100*38)-0.5)*2




uni <- t(apply(X, 2, function(x, idx = which(Y == comp),
    y = Y) {
    (cd(x[idx], x[-idx]))
  }))

cd<-function (ref, comp) 
 {top_counts <- vapply(ref, function(x, y = comp) {
     names(x) <- NULL
     names(y) <- NULL
     c(length(which(x > y)), length(which(x < y)))
   }, FUN.VALUE = c(2, length(ref)))
   out <- ((sum(top_counts[1, ]) - sum(top_counts[2, ]))/(length(ref) * 
     length(comp))) * (-1)
   return(out)
 }

idx<- which(BIOspcglyc[,"covid_status"]=="control")
yy<- BIOspcglyc[-idx,]
xx<- BIOspcglyc[idx,]

cd(xx$SPC_All, yy$SPC_All)
#[1] -0.7705263

reseff<-effsize::cliff.delta(y, x, return.dm = TRUE)
#-0.7705263

# x= yy$SPC_All
# y= xx$SPC_All

idx<- which(BIOspcglyc[,"covid_status"]=="control")
yy<- BIOspcglyc[-idx,]
xx<- BIOspcglyc[idx,]
ref = xx[,1]
comp= yy[,1]
top_counts <- vapply(ref, function(x, y = comp) {
     names(x) <- NULL
     names(y) <- NULL
     c(length(which(x > y)), length(which(x < y)))
   }, FUN.VALUE = c(2, length(ref)))

#      names(x) <- NULL
#      names(y) <- NULL
#      c(length(which(x > y)), length(which(x < y)))
#    #86 14
# idx <- which(x > y)
# idy <- which(x < y)
# 
# xxx<-x[idx]
# sum(xxx)
# 
# yyy<-x[idy]
# sum(yyy)
# 
# (sum(x[idx])-sum(x[idy]))/(86*14)

   out <- ((sum(top_counts[1, ]) - sum(top_counts[2, ]))/(length(ref) * 
     length(comp))) * (-1)
df<-
tc<-list(df[which(factor==1),1], df[which(factor==2),1])   
tc<-list(mod@X[which(Y==1),1],mod@X[which(Y==0),1])
control = tc[[2]]
treatment = tc[[1]]
control<-sort(control)
treatment<-sort(treatment)
n1 = length(treatment)
n2 = length(control)
rescale.factor = (n1*n2-1)/(n1*n2)

dominance = sign(outer(treatment, control, FUN="-")) 
row.names(dominance) = treatment
colnames(dominance) = control

d = mean(dominance)

d. = ifelse(abs(d)==1,d*rescale.factor,d)

#manually calculate cliffs delta
#split into control and treatment
idx<- which(BIOspcglyc[,"covid_status"]=="control")
BIOspcglycR<- BIOspcglyc
control <- BIOspcglycR[idx,]
treatment <- BIOspcglycR[-idx,]

#sort from smallest to largest for one sample col
control<-sort(control$SPC_All)
treatment<-sort(treatment$SPC_All)

#find length of control and treatment
n1 = length(treatment)
n2 = length(control)

#make a matrix using control and treatment: set as one column for treatment(eg 100x1 matrix) and one row for control (eg 1x38 matrix) using outer, and do minus using FUN. reassign any negative as -1, any positive as +1 any 0 is left as 0
dominance = sign(outer(treatment, control, FUN="-")) 

#calculate the mean of each entry in dominance. d is cliffs delta
d = mean(dominance)


#use the values 
row.names(dominance) = treatment
colnames(dominance) = control
rescale.factor = (n1*n2-1)/(n1*n2)
d. = ifelse(abs(d)==1,d*rescale.factor,d)

#pvalue calculation 
x<-BIOspcglyc$SPC_All
y<-BIOspcglyc$covid_status_factor
kruskal.test(x, y)$p.value
```
