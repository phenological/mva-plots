---
title: "ropls test"
author: "Lucy Grigoroff"
date: "2023-07-11"
output: html_document
---



```{r}
functionDir <- "./R/"
functionList <- list.files(path = functionDir)
for(i in functionList){
  source(paste0(functionDir,i))
}

```

## load data

```{r pressure, echo=FALSE}
ann<-local(get(load("~/OneDrive - Murdoch University/datasets/covid19/bioGune/dataElements/covid19_bioGune_PLA_ANN.daE")))
aaMeta1<-ann@obsDescr[[1]]

aa<-local(get(load(file.path("~/OneDrive - Murdoch University/datasets/covid19/bioGune/dataElements/covid19_bioGune_PLA_SPC.daE"))))
aaData<-data.frame(apply(aa@.Data,2,as.numeric)) #spc/glyc data
aaMeta2<-aa@obsDescr[[1]] #metadata from PLA_SPC.daE file

# match SpcGlyc numeric and both Annotations
aaMeta1<-aaMeta1[which(aaMeta1$sampleID %in% aaMeta2$sampleID),]
aaData<-aaData[which(aaMeta2$sampleID %in% aaMeta1$sampleID),]
aaMeta2<-aaMeta2[which(aaMeta2$sampleID %in% aaMeta1$sampleID),]

#make a final annotation file
aaMetaF<-merge(aaMeta1,
                  aaMeta2,
                  by.x ="sampleID",by.y = "sampleID")
rm(aaMeta1, aaMeta2, aa, ann)

#combine the numeric and meta data
BIOspcglyc<-cbind(aaData, aaMetaF)
rm(aaData, aaMetaF)

#Organise the data as you wish 

which(BIOspcglyc[, 1:8]=="Inf")
which(is.na(BIOspcglyc[, 1:8]))
which(is.na(BIOspcglyc$age))
unique(BIOspcglyc$sex)

unique(BIOspcglyc$group)
BIOspcglyc$covid_status<-ifelse(BIOspcglyc$group =="COVID-pos","covid", ifelse(BIOspcglyc$group=="preCOVID","control", "control"))

library(fusion)
library(dplyr)
lipo<-local(get(load("~/OneDrive - Murdoch University/datasets/covid19/cambridgeFollowUpPart2/DataElements/covid19_cambridge_ORI_FU1_FU2_PLA_LIPO.daE")))
LIPO<-data.frame(apply(lipo@.Data,2,as.numeric))
LIPO_ANN<-lipo@obsDescr[[1]]

ann<-local(get(load("~/OneDrive - Murdoch University/datasets/covid19/cambridge/DataElements/covid19_cambridge_PLA_ANN_fix.daE")))
#ann<-local(get(load("~/Downloads/covid19_cambridge_PLA_ANN.daE")))
ann = ann@obsDescr[[1]]

#matching the annotation file fo the LIPO_ANN file

ann<-ann[which(ann$sampleID %in% LIPO_ANN$sampleID),]
LIPO<- LIPO[which(LIPO_ANN$sampleID %in% ann$sampleID),]
LIPO_ANN<- LIPO_ANN[which(LIPO_ANN$sampleID %in% ann$sampleID),]

LIPO<- LIPO[match(ann$sampleID, LIPO_ANN$sampleID),]
LIPO_ANN<- LIPO_ANN[match(ann$sampleID, LIPO_ANN$sampleID),]

df<-cbind(LIPO, ann)
rm(ann, LIPO, LIPO_ANN)

df2 <-
  df %>%
  filter(!is.na(age)) %>%
  filter(!is.na(group_facet_letter))%>%
  group_by(group_facet_letter, gender) 

which(df2 == "Inf", arr.ind = TRUE)

#remove rows with Inf values for lipoprotein quantities
df3 <- df2[-c(49,70,548),]

rm(df, df2)


# ann<-local(get(load("~/OneDrive - Murdoch University/datasets/busselton/datasets/annotations/toDelete/")))
# aaMeta1<-ann@obsDescr[[1]]

aa<-local(get(load(file.path("~/OneDrive - Murdoch University/datasets/busselton/DataElements/Busselton_PLA_PGPE_SPC.daE"))))
aaData<-data.frame(apply(aa@.Data,2,as.numeric)) #spc/glyc data
# aaMeta2<-aa@obsDescr[[1]] #metadata from PLA_SPC.daE file
# 
# # match SpcGlyc numeric and both Annotations
# aaMeta1<-aaMeta1[which(aaMeta1$sampleID %in% aaMeta2$sampleID),]
# aaData<-aaData[which(aaMeta2$sampleID %in% aaMeta1$sampleID),]
# aaMeta2<-aaMeta2[which(aaMeta2$sampleID %in% aaMeta1$sampleID),]
# 
# #make a final annotation file
# aaMetaF<-merge(aaMeta1,
#                   aaMeta2,
#                   by.x ="sampleID",by.y = "sampleID")
# rm(aaMeta1, aaMeta2, aa, ann)
# 
# #combine the numeric and meta data
# CAMspcglyc<-cbind(aaData, aaMetaF)
# rm(aaData, aaMetaF)
```
```{r}
#1 make the model
lo<-oplsda(X=BIOspcglyc[,1:8], Y=BIOspcglyc$age, type = "PLS", optns=list(predI = 3, permI= 100))

#2 predict with newdata 
lot <-oplsdaPredict(model = lo, newdata = aaData)

#mtcars test
il<- oplsda(X=mtcars[,1:7], Y=mtcars[,8], type = "PLS", optns=list(scaleC="none"))

singlePlot(model=lot, optns = list(ellipse = "hotellings"))
```

```{r}
#1 create PCA object
a <- PCA(BIOspcglyc[,1:8], annotation = BIOspcglyc[,-1:-8])
a1 <- PCA(df3[,1:112], annotation = df3[,-1:-112], rank = 20)

#2
fff<- plotScores(model=a, optns=list(color=BIOspcglyc$age, ellipse="hotellings", shape=BIOspcglyc$sex, outlierLabels=row.names(BIOspcglyc)))
fff[["plots"]][["pcaGrid"]]

#ropls objects
plotScores(model = lo, optns = list(color =BIOspcglyc$age, ellipse = "hotellings"))

#2
fff<- plotLoadings(model= a)
fff[["plots"]][["plotLoadingGrid"]]
```
```{r}
df2 <- as.data.frame(cbind(lo@loadingMN, lo@orthoLoadingMN))
df2 <-cbind(df2, lo@suppLs[["yMCN"]])

singlePlot(model = fff, optns=list( i=2, j=3, plotTitle="PC2vPC3"))
i=2 
j=3
onePlot <- fff[["plots"]][["pcaGrid"]][j,i]+
      ggtitle("plotTitle") +
      labs(shape = fff$extra$shapeTitle,
           color = fff$extra$colorTitle,
           size = fff$extra$sizeTitle,
           alpha = fff$extra$alphaTitle,
           x = fff$extra$axisTitle[i],
           y = fff$extra$axisTitle[j+1]) +
      theme_minimal()

#score plot
gg_circle2 <- function(rx, ry, xc, yc, color = "grey", fill = NA, linetype="dashed", ...) {
  x <- xc + rx * cos(seq(0, pi, length.out = 100))
  ymax <- yc + ry * sin(seq(0, pi, length.out = 100))
  ymin <- yc + ry * sin(seq(0, -pi, length.out = 100))
  annotate(
    "ribbon",
    x = x, ymin = ymin, ymax = ymax,
    color = color, fill = fill, linetype = linetype)
}

df <- as.data.frame(cbind(lo@scoreMN))
df <-cbind(df, lo@suppLs[["yMCN"]])
ci<-0.95
    n <- nrow(df)

    hotFisN <- (n - 1) * 2 * (n^2 - 1) / (n^2 * (n - 2)) * qf(ci, 2, n - 2)
ggplot(data = df, aes(x=df[,1], y=df[,2])) + 
  geom_point(aes(color=y1, shape=BIOspcglyc$sex))+ 
  scale_color_gradientn(
        colors = c(
          "#0000CC",
          "#0000FF",
          "#0055FF",
          "#00AAFF",
          "#00FFFF",
          "#2BFFD5",
          "#55FFAA",
          "#80FF80",
          "#AAFF55",
          "#D4FF2B",
          "#FFFF00",
          "#FFAA00",
          "#FF5500",
          "#FF0000",
          "#CC0000"
        ),
        na.value = "grey50",
        guide = "colorbar"
      )+
  geom_hline(yintercept = 0, colour = "gray70") + 
  geom_vline(xintercept = 0, colour = "gray70")+ 
  labs(caption = expression("no ellipse")) + 
  theme_bw() +
  gg_circle2(rx = sqrt(var(df[,1]) * hotFisN),
                      ry = sqrt(var(df[,2]) * hotFisN),
                      xc = 0,
                      yc = 0) +
  labs(color="over")
# + geom_text(
#                   data = df[idx, ],
#                   aes(label = p1),
#                   size = 2,
#                   hjust = 0,
#                   vjust = 0
#                 )

##for outliers
rx <- sqrt(var(df[,1]) * hotFisN)
ry <- sqrt(var(df[,2]) * hotFisN)

insideOut <- list((df[,1]^2)/(rx^2) + (df[,2]^2)/(ry^2))
idx <- which(insideOut[[1]] > 1)

outlierIDX <- df[idx,-1:-ncol(df)]

```

Need to ensure 
1. Save the scaling transformation in the returned object
2. Allow to save all models from permutation tests and cross-validations in the return object.

y	
Response to be modelled: Either 1) 'NULL' for PCA (default) or 2) a numerical vector (same length as 'x' row number) for single response (O)PLS, or 3) a numerical matrix (same row number as 'x') for multiple response PLS, 4) a factor (same length as 'x' row number) for (O)PLS-DA, or 5) a character indicating the name of the column of the phenoData@data to be used, when x is a SummarizedExperiment or an ExpressionSet object. Note that, for convenience, character vectors are also accepted for (O)PLS-DA as well as single column numerical (resp. character) matrix for (O)PLS (respectively (O)PLS-DA). NAs are allowed in numeric responses.

orthoI	
Integer: number of orthogonal components (for OPLS only); when set to 0 [default], PLS will be performed; otherwise OPLS will be peformed; when set to NA, OPLS is performed and the number of orthogonal components is automatically computed by using the cross-validation (with a maximum of 9 orthogonal components).

predI	
Integer: number of components (predictive componenents in case of PLS and OPLS) to extract; for OPLS, predI is (automatically) set to 1; if set to NA [default], autofit is performed: a maximum of 10 components are extracted until (ii) PLS case: either R2Y of the component is < 0.01 (N4 rule) or Q2Y is < 0 (for more than 100 observations) or 0.05 otherwise (R1 rule)

permI	
Integer: number of random permutations of response labels to estimate R2Y and Q2Y significance by permutation testing [default is 20 for single response models (without train/test partition), and 0 otherwise]
```{r}
library(ropls)
b<-prcomp(BIOspcglyc[,1:8], scale. =TRUE)
a<-ropls::opls(x = BIOspcglyc[,1:8], y = BIOspcglyc[,"covid_status"], predI = 0, orthoI = NA, crossvalI = 10, permI = 50)

b <-ropls::predict(object = a, aaData)

c<-metabom8::opls(X=BIOspcglyc[,1:8], Y=BIOspcglyc[,"covid_status"])

aaData <- as.matrix(aaData)
d <-metabom8::predict_opls(opls_model = c, newdata = aaData)
# (opls_model = c, newdata = , idx_scale = NULL)



f <- ropls::opls(x=BIOspcglyc[,1:8], y=BIOspcglyc[,"age"], predI = 0, orthoI = NA)
g <- metabom8::opls(X=BIOspcglyc[,1:8], Y=BIOspcglyc[,"age"])

b <-ropls::predict(object = f, aaData)
d <-metabom8::predict_opls(opls_model = c, newdata = aaData)
```
```{r}
data(iris)

# split data into 2 parts for pca training (75%) and prediction (25%)
set.seed(1)
samp <- sample(nrow(iris), nrow(iris)*0.75)
iris.train <- iris[samp,]
iris.valid <- iris[-samp,]

# conduct PCA on training dataset
pca <- prcomp(iris.train[,1:4], retx=TRUE, center=TRUE, scale=TRUE)
expl.var <- round(pca$sdev^2/sum(pca$sdev^2)*100) # percent explained variance

# prediction of PCs for validation dataset
pred <- predict(pca, newdata=iris.valid[,1:4])

###Plot result
COLOR <- c(2:4)
PCH <- c(1,16)

pc <- c(1,2) # principal components to plot

png("pca_pred.png", units="in", width=5, height=4, res=200)
op <- par(mar=c(4,4,1,1), ps=10)
plot(pca$x[,pc], col=COLOR[iris.train$Species], cex=PCH[1], 
 xlab=paste0("PC ", pc[1], " (", expl.var[pc[1]], "%)"), 
 ylab=paste0("PC ", pc[2], " (", expl.var[pc[2]], "%)")
)
points(pred[,pc], col=COLOR[iris.valid$Species], pch=PCH[2])
legend("topright", legend=levels(iris$Species), fill = COLOR, border=COLOR)
legend("topleft", legend=c("training data", "validation data"), col=1, pch=PCH)
par(op)
dev.off()

```

```{r}
pred <- predict(a, newdata=aaData)

## training and a test partition
    
    if(subsetL) {
      
      xTesMN <- xMN[-subsetVi, , drop = FALSE]
      xMN <- xMN[subsetVi, , drop = FALSE]
      yMN <- yMN[subsetVi, , drop = FALSE]
      
    }
  
  ## Observation names
  
  if(!is.null(rownames(xMN))) {
    obsNamVc <- rownames(xMN)
  } else
    obsNamVc <- as.character(1:nrow(xMN))
  
  ## tRaining/tEst partition
        
        xteMN <- scale(xTesMN, xMeanVn, xSdVn)
        
        for(noN in 1:orthoI) {
          if(naxL) {
            xtoMN <- matrix(0, nrow = nrow(xteMN), ncol = 1)
            for(i in 1:nrow(xtoMN)) {
              comVl <- complete.cases(xteMN[i, ])
              xtoMN[i, ] <- crossprod(xteMN[i, comVl], woMN[comVl, noN]) / drop(crossprod(woMN[comVl, noN]))
            }
          } else
            xtoMN <- xteMN %*% woMN[, noN]
          
          xteMN <- xteMN - tcrossprod(xtoMN, poMN[, noN])
        }
        
        if(naxL) {
          yTesScaMN <- matrix(0, nrow = nrow(xteMN), ncol = ncol(bMN), dimnames = list(rownames(xteMN), colnames(bMN)))
          for(j in 1:ncol(yTesScaMN))
            for(i in 1:nrow(yTesScaMN)) {
              comVl <- complete.cases(xteMN[i, ])
              yTesScaMN[i, j] <- crossprod(xteMN[i, comVl], bMN[comVl, j])
            }
        } else
          yTesScaMN <- xteMN %*% bMN
        
        if(nayL)
          yTesScaMN <- yTesScaMN[!is.na(yMCN[setdiff(1:nrow(yMCN), subsetVi), ]), , drop = FALSE]
        
        yTesMN <- scale(scale(yTesScaMN,
                              FALSE,
                              1 / ySdVn),
                        -yMeanVn,
                        FALSE)
        attr(yTesMN, "scaled:center") <- NULL
        attr(yTesMN, "scaled:scale") <- NULL
        
        if(mode(yMCN) == "character") {
          yTestMCN <- .char2numF(yTesMN,
                                 c2nL = FALSE)
        } else
          yTestMCN <- yTesMN
        
        yTesActMCN <- yMCN[setdiff(1:nrow(yMCN), subsetVi), , drop = FALSE] ## actual values
        if(mode(yMCN) == "character") {
          yTesActMN <- .char2numF(yTesActMCN)
        } else
          yTesActMN <- yTesActMCN
        
        summaryDF[, "RMSEP"] <- .errorF(c(yTesMN), c(yTesActMN))
        
      } else
        yTestMCN <- NULL
      
      
    } ## end of OPLS

  
```


```{r}
function (opls_model, newdata, idx_scale = NULL) 
{
  if (is.null(ncol(newdata))) {
    X <- rbind(newdata)
  }
  else {
    X <- newdata
  }
  if (length(opls_model@X_mean) != ncol(newdata)) {
    stop("Newdata argument does not match training data.")
  }
  if (!is.null(idx_scale)) {
    map_scale <- c(none = 0L, UV = 1L)
    map_scale[match(opls_model@Parameters$scale, names(map_scale))]
    sc_res <- .scaleMatRcpp(X, idx_scale - 1, center = opls_model@Parameters$center, 
      scale_type = map_scale[match(opls_model@Parameters$scale, 
        names(map_scale))])
    X <- sc_res$X_prep
  }
  else {
    if (all(!is.null(opls_model@X_mean) & !is.na(opls_model@X_mean)) && 
      all(!is.null(opls_model@X_sd) & !is.na(opls_model@X_sd))) {
      Xmc <- sweep(X, 2, opls_model@X_mean, FUN = "-")
      X <- sweep(Xmc, 2, opls_model@X_sd, FUN = "/")
    }
  }
  e_new_orth <- X
  n_pcOorth = opls_model@nPC - 1
  t_orth <- matrix(NA, nrow = nrow(X), ncol = n_pcOorth)
  for (i in seq_len(n_pcOorth)) {
    t_orth[, i] <- e_new_orth %*% t(t(opls_model@w_orth[i, 
      ]))/drop(crossprod(t(t(opls_model@w_orth[i, ]))))
    e_new_orth <- e_new_orth - (cbind(t_orth[, i]) %*% t(opls_model@p_orth[i, 
      ]))
  }
  if ((n_pcOorth) > 1) {
    pc.orth <- pca(t_orth, pc = 1, scale = "UV")
    t_orth_pca <- pc.orth@t[, 1]
  }
  else {
    t_orth_pca <- NULL
  }
  t_pred <- e_new_orth %*% (opls_model@w_pred)
  betas <- opls_model@betas_pred
  q_h <- opls_model@Qpc
  res <- matrix(NA, nrow = nrow(X), ncol = ncol(opls_model@t_pred))
  for (i in seq_len(ncol(opls_model@t_pred))) {
    opts <- t(cbind(betas[i]) %*% t_pred[, i]) %*% rbind(q_h[, 
      i])
    res[, i] <- apply(opts, 1, sum)
  }
  totalPrediction <- apply(res, 1, sum)
  Y_predicted <- (totalPrediction * opls_model@Y_sd) + opls_model@Y_mean
  if (opls_model@type == "DA") {
    cs <- table(opls_model@Y$ori, opls_model@Y$dummy)
    levs <- data.frame(Original = rownames(cs), Numeric = as.numeric(colnames(cs)), 
      stringsAsFactors = FALSE, row.names = NULL)
    Y_predicted <- levs$Original[apply(vapply(levs$Numeric, 
      function(x, y = Y_predicted) {
        abs(x - y)
      }, Y_predicted), 1, which.min)]
  }
  out <- list(Y_predicted = Y_predicted, t_pred = t_pred, 
    t_orth = t_orth, t_orth_pca = t_orth_pca)
  return(out)
}
##The criterion for evaluating whether there is overfitting in the OPLS-DA model is that the regression line at a blue Q2 point crosses or is less than 0 from the abscissa. Overfitting looking at permutation:
# pQ2 = (1+ No of permuted Q2(cum) > actual Q2(cum) found in permMN)/(nrows permMN -1), so if it's 50 permutations, permMN has 51 entries (50 permutations + the actual Q2(cum), so if none of the permutated Q2(cum) is above the actual Q2(cum), pQ2=(1+0)/(51-1)=0.02, meaning overfitting is less likely). 

#center and scale the new data
##mean centered
Xmc <- sweep(X, 2, opls_model@xMeanVn, FUN = "-")
##scaled
X <- sweep(Xmc, 2, opls_model@xSdVn, FUN = "/")


#e_new_orth & t_orth
  e_new_orth <- X
  n_pcOorth = opls_model@nPC - 1 #change
  ##make empty t_orth matrix
  t_orth <- matrix(NA, nrow = nrow(X), ncol = n_pcOorth)
  ##fill t_orth matrix and transform e_new_orth
  for (i in seq_len(n_pcOorth)) {
    t_orth[, i] <- e_new_orth %*% t(t(opls_model@orthoWeightMN[i,]))/drop(crossprod(t(t(opls_model@orthoWeightMN[i, ]))))
    e_new_orth <- e_new_orth - (cbind(t_orth[, i]) %*% t(opls_model@orthoLoadingMN[i,]))
  }

#set t_orth_pca
  if ((n_pcOorth) > 1) {
    pc.orth <- pca(t_orth, pc = 1, scale = "UV")
    t_orth_pca <- pc.orth@t[, 1]
  }
  else{t_orth_pca <- NULL}
  
#required elements for calculations 
  ##predictive scores
  t_pred <- e_new_orth %*% (opls_model@weightMN)
  ##Regression coefficients
  betas <- opls_model@betas_pred #change
  ##Predictive component weights for Y
  q_h <- opls_model@cMN
  
  
#Results
  ##make empty results matrix
  res <- matrix(NA, nrow = nrow(X), ncol = ncol(opls_model@scoreMN))
  ##fill results matrix
  for (i in seq_len(ncol(opls_model@scoreMN))) {
    opts <- t(cbind(betas[i]) %*% t_pred[, i]) %*% rbind(q_h[,i])
    res[, i] <- apply(opts, 1, sum)
  }  

#Make Y predictions
 totalPrediction <- apply(res, 1, sum)
  Y_predicted <- (totalPrediction * opls_model@ySdVn) + opls_model@Y_mean #change Y_mean, results differ by 1 with @yMeanVn
  
#if it's discriminant analysis, transform the Y predicted into desired results (control and treatment for example)
  if (opls_model@type == "DA") {
    cs <- table(opls_model@Y$ori, opls_model@Y$dummy)
    levs <- data.frame(Original = rownames(cs), Numeric = as.numeric(colnames(cs)), stringsAsFactors = FALSE, row.names = NULL)
    Y_predicted <- levs$Original[apply(vapply(levs$Numeric, 
      function(x, y = Y_predicted) {
        abs(x - y)
      }, Y_predicted), 1, which.min)]
  }
  
#all desired output
  out <- list(Y_predicted = Y_predicted, 
              t_pred = t_pred, 
              t_orth = t_orth, 
              t_orth_pca = t_orth_pca)
  return(out)
```

```{r}
newdata <- aaData
object <- ropls::opls(x = BIOspcglyc[,1:8], y = BIOspcglyc[,"covid_status"], predI = 0, orthoI = NA, crossvalI = 10, permI = 50)

#center and scale new data
xteMN <- scale(newdata, object@xMeanVn, object@xSdVn)
              
              if(object@summaryDF[, "ort"] > 0) {
                
                for(noN in 1:object@summaryDF[, "ort"]) {
                  if(object@suppLs[["naxL"]]) {
                    #make empty matrix
                    #   t_orth <- matrix(NA, nrow = nrow(X), ncol = n_pcOorth)
                    xtoMN <- matrix(0, nrow = nrow(xteMN), ncol = 1)
                    for(i in 1:nrow(xtoMN)) {
                      #ensure pick rows without NAs
                      comVl <- complete.cases(xteMN[i, ])
                      #calculate 
                      #   t_orth[, i] <- e_new_orth %*% t(t(opls_model@orthoWeightMN[i,]))/drop(crossprod(t(t(opls_model@orthoWeightMN[i, ])))) #16 (&17)
                      xtoMN[i, ] <- crossprod(xteMN[i, comVl], object@orthoWeightMN[comVl, noN]) / drop(crossprod(object@orthoWeightMN[comVl, noN])) 
                    }
                  } else
                    
                    xtoMN <- xteMN %*% object@orthoWeightMN[, noN]
                  t_pred <- xteMN %*% object@weightMN[, noN]
                  xteMN <- xteMN - tcrossprod(xtoMN, object@orthoLoadingMN[, noN])
                  
                     
                  #     e_new_orth <- e_new_orth - (cbind(t_orth[, i]) %*% t(opls_model@orthoLoadingMN[i,])) #18
              
                  
                  #   t_pred <- e_new_orth %*% (opls_model@weightMN) #19
                    
                }
                
              }
              
# #e_new_orth & t_orth
#   e_new_orth <- X
#   n_pcOorth = opls_model@nPC - 1 #change
#   ##make empty t_orth matrix
#   t_orth <- matrix(NA, nrow = nrow(X), ncol = n_pcOorth)
#   ##fill t_orth matrix and transform e_new_orth
#   for (i in seq_len(n_pcOorth)) {
#     t_orth[, i] <- e_new_orth %*% t(t(opls_model@orthoWeightMN[i,]))/drop(crossprod(t(t(opls_model@orthoWeightMN[i, ])))) #16 (& 17?)
#     e_new_orth <- e_new_orth - (cbind(t_orth[, i]) %*% t(opls_model@orthoLoadingMN[i,])) #18
#   }
# 
# #set t_orth_pca
#   if ((n_pcOorth) > 1) {
#     pc.orth <- pca(t_orth, pc = 1, scale = "UV")
#     t_orth_pca <- pc.orth@t[, 1]
#   }
#   else{t_orth_pca <- NULL}
#   
# #required elements for calculations 
#   ##predictive scores
#   t_pred <- e_new_orth %*% (opls_model@weightMN) #19

## if(object@suppLs[["nayL"]])
              ##     yTesScaMN <- yTesScaMN[!is.na(yMCN[testVi, ]), , drop = FALSE]
              
if(object@suppLs[["naxL"]]) {
                yTesScaMN <- matrix(0, nrow = nrow(xteMN), ncol = ncol(object@coefficientMN),
                                    dimnames = list(rownames(xteMN), colnames(object@coefficientMN)))
                for(j in 1:ncol(yTesScaMN))
                  for(i in 1:nrow(yTesScaMN)) {
                    comVl <- complete.cases(xteMN[i, ])
                    yTesScaMN[i, j] <- crossprod(xteMN[i, comVl], object@coefficientMN[comVl, j])
                  }
              } else
                yTesScaMN <- xteMN %*% object@coefficientMN
              yTesMN <- scale(scale(yTesScaMN,
                                    FALSE,
                                    1 / object@ySdVn),
                              -object@yMeanVn,
                              FALSE)
              attr(yTesMN, "scaled:center") <- NULL
              attr(yTesMN, "scaled:scale") <- NULL
              
              if(is.factor(fitted(object))) {
                
                yTestMCN <- object@suppLs[[".char2numF"]](yTesMN,
                                                          c2nL = FALSE)
                predMCNFcVcn <- as.character(yTestMCN)
                names(predMCNFcVcn) <- rownames(newdata)
                predMCNFcVcn <- factor(predMCNFcVcn, levels = levels(object@suppLs[["y"]]))
                
              } else if(is.vector(fitted(object))) {
                
                if(is.character(fitted(object))) {
                  
                  yTestMCN <- object@suppLs[[".char2numF"]](yTesMN,
                                                            c2nL = FALSE)
                  predMCNFcVcn <- as.character(yTestMCN)
                  names(predMCNFcVcn) <- rownames(newdata)
                  
                } else {
                  
                  predMCNFcVcn <- as.numeric(yTesMN)
                  names(predMCNFcVcn) <- rownames(newdata)
                  
                }
                
              } else if (is.matrix(fitted(object))) {
                
                if (mode(fitted(object)) == "character") {
                  predMCNFcVcn  <- object@suppLs[[".char2numF"]](yTesMN, c2nL = FALSE)
                } else
                  predMCNFcVcn <- yTesMN
                
                rownames(predMCNFcVcn) <- rownames(newdata)
                
              }
              
              return(predMCNFcVcn)
              
            }
            
          })
```
```{r}

lot<-ropls::opls(x = BIOspcglyc[,1:8], y = BIOspcglyc$covid_status, predI = 1, orthoI = NA, permI=20, subset = "odd")
```

